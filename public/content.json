[{"title":"Angular-结构指令","date":"2017-07-30T17:11:43.000Z","path":"2017/07/31/angular-structDirective/","text":"结构型指令可以很方便的DOM结构树，Angular有一个强力的模板引擎来支持这一些，比如：添加、移除或维护DOM元素例如： &lt;div *ngIf=&quot;hero&quot; &gt;{{hero.name}}&lt;/div&gt; 内置结构指令（1）NgIf &lt;div *ngIf=&quot;hero&quot; &gt;{{hero.name}}&lt;/div&gt; 接受一个条件值，当条件为假时，从DOM中移除它的宿主元素，取消它监听过的那些DOM事件，从Angular变更检测中移除该组件，并销毁它，DOM节点可以被当做垃圾收集起来，并且释放它们占用的内存；否则，则添加它们解开语法糖： &lt;div *ngIf=&quot;hero&quot; class=&quot;active&quot;&gt;{{hero.name}}&lt;/div&gt; --&gt; &lt;div template=&quot;ngIf hero&quot; class=&quot;active&quot;&gt;{{hero.name}}&lt;/div&gt; --&gt; &lt;ng-template [ngIf]=&quot;hero&quot;&gt; &lt;div class=&quot;active&quot;&gt;{{hero.name}}&lt;/div&gt; &lt;/ng-template&gt; 上述解开的形式不会真的渲染出来，angular渲染时会移除ng-template，并辅以标记性注释占位，真正添加到DOM树里的是里面的div部分 （2）NgFor &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero.name}}&lt;/div&gt; 指令接受一个模板表达式，对数据列表进行迭代，应用于宿主元素，并将宿主元素及其子元素一起克隆多份置于DOM树上解开语法糖： &lt;div *ngFor=&quot;let hero of heroes; let i=index; let odd=odd; trackBy: trackById&quot; [class.odd]=&quot;odd&quot;&gt; ({{i}}) {{hero.name}} &lt;/div&gt; --&gt; &lt;div template=&quot;ngFor let hero of heroes; let i=index; let odd=odd; trackBy: trackById&quot; [class.odd]=&quot;odd&quot;&gt; ({{i}}) {{hero.name}} &lt;/div&gt; --&gt; &lt;ng-template ngFor let-hero [ngForOf]=&quot;heroes&quot; let-i=&quot;index&quot; let-odd=&quot;odd&quot; [ngForTrackBy]=&quot;trackById&quot;&gt; &lt;div [class.odd]=&quot;odd&quot;&gt;({{i}}) {{hero.name}}&lt;/div&gt; &lt;/ng-template&gt; 这个比较复杂： let关键字声明一个模板输入变量，本例中就是hero、i和odd； 解析器会把let hero、let i和let odd翻译成命名变量let-hero、let-i和let-odd 微语法解析器接收of和trackby，把它们首字母大写（of -&gt; Of, trackBy -&gt; TrackBy）， 并且给它们加上指令的属性名（ngFor）前缀，最终生成的名字是ngForOf和ngForTrackBy 两个NgFor的输入属性分别是，列表heroes，track-by函数是trackById NgFor指令在列表上循环，每个循环中都会设置和重置它自己的上下文对象上的属性。 这些属性包括index和odd以及一个特殊的属性名$implicit（隐式变量，let-hero） （3）NgSwitch &lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt; &lt;happy-hero *ngSwitchCase=&quot;&apos;happy&apos;&quot; [hero]=&quot;hero&quot;&gt;&lt;/happy-hero&gt; &lt;sad-hero *ngSwitchCase=&quot;&apos;sad&apos;&quot; [hero]=&quot;hero&quot;&gt;&lt;/sad-hero&gt; &lt;confused-hero *ngSwitchCase=&quot;&apos;confused&apos;&quot; [hero]=&quot;hero&quot;&gt;&lt;/confused-hero&gt; &lt;unknown-hero *ngSwitchDefault [hero]=&quot;hero&quot;&gt;&lt;/unknown-hero&gt; &lt;/div&gt; NgSwitch不是结构指令，只是属性指令，用来接受“状态值”；NgSwitchCase和NgSwitchDefault是结构型指令，用来根据状态来匹配显示不同的分支DOM,用法额原理都类似于NGIF解开语法糖： &lt;div [ngSwitch]=&quot;hero?.emotion&quot;&gt; &lt;ng-template [ngSwitchCase]=&quot;&apos;happy&apos;&quot;&gt; &lt;happy-hero [hero]=&quot;hero&quot;&gt;&lt;/happy-hero&gt; &lt;/ng-template&gt; &lt;ng-template [ngSwitchCase]=&quot;&apos;sad&apos;&quot;&gt; &lt;sad-hero [hero]=&quot;hero&quot;&gt;&lt;/sad-hero&gt; &lt;/ng-template&gt; &lt;ng-template [ngSwitchCase]=&quot;&apos;confused&apos;&quot;&gt; &lt;confused-hero [hero]=&quot;hero&quot;&gt;&lt;/confused-hero&gt; &lt;/ng-template &gt; &lt;ng-template ngSwitchDefault&gt; &lt;unknown-hero [hero]=&quot;hero&quot;&gt;&lt;/unknown-hero&gt; &lt;/ng-template&gt; &lt;/div&gt; 注意： 模板输入变量时一个模块实例的变量值，可以使用到当前实例中；而模板引用变量时引用的元素，代表的时那个元素本身，可在当前整个文档中使用；两种有不同的命名空间 一个元素不同时使用两个结构型实例 ng-template/ng-container（1）ng-template&lt;ng-template&gt;是一类html标签，是angular用来解释渲染结构性指令的一种方式，不会直接显示在html,最后会替换成同意义的注释；比如ngif中，当条件为false，angular将移除相应分支元素，取而代之的时一段注释这个标签直接单独使用的时候也有次效果，比如： &lt;ng-template&gt;&lt;p&gt;AA&lt;/p&gt;&lt;/ng-template&gt; 包裹的元素内容在渲染时会消失，而代之的是注释 （2）ng-container&lt;ng-container&gt;是一种不影响当前样式/布局的组合元素,angular只是用它来包裹控制内部元素的显示不显示，最后是不会添加渲染到DOM树上的，也不会有注释，使用起来就像普通语言中的if条件一样；它可直接包裹任何元素，包括文本 &lt;p&gt; I turned the corner &lt;ng-container *ngIf=&quot;hero&quot;&gt; and saw {{hero.name}}. I waved &lt;/ng-container&gt; and continued on my way. &lt;/p&gt; 有些元素不能直接使用其他标签包裹，比如select中的option，必须和select挨着，否则会出问题；这是不能使用ngif或ng-template，但可以使用ng-container，它不会有副作用，因为最后都会移除掉 &lt;select [(ngModel)]=&quot;hero&quot;&gt; &lt;ng-container *ngFor=&quot;let h of heroes&quot;&gt; &lt;ng-container *ngIf=&quot;showSad || h.emotion !== &apos;sad&apos;&quot;&gt; &lt;option [ngValue]=&quot;h&quot;&gt;{{h.name}} ({{h.emotion}})&lt;/option&gt; &lt;/ng-container&gt; &lt;/ng-container&gt; &lt;/select&gt; 会根据heros动态显示option,而所有的ng-container标签最后都会移除，否则会影响option显示 自定义结构指令指令作用：使用数字来控制元素的增加和移除，类似于ngIf，接受源字符串，当输入是数字时添加；输入是非数字或空串，移除宿主元素 import { Directive, Input, TemplateRef, ViewContainerRef} from &apos;@angular/core&apos;; @Directive({ selector: &apos;[numIf]&apos; }) export class NumIfDirective { private hasView = false; constructor(private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef) { } @Input() set numIf(condition: any) { if (condition &amp;&amp; !isNaN(condition) &amp;&amp; !this.hasView) { this.viewContainer.createEmbeddedView(this.templateRef); this.hasView = true; } else if (isNaN(condition) &amp;&amp; this.hasView) { this.viewContainer.clear(); this.hasView = false; } } } 使用的地方 &lt;div&gt; &lt;label&gt;请输入： &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; [(ngModel)]=&quot;myValue&quot;&gt; &lt;/div&gt; &lt;p *numIf=&quot;myValue&quot;&gt;输入的值是： {{myValue}}&lt;/p&gt; 效果如下： 其他，一些好东西：1 . 自定义结构指令里头，有几个新的概念，这里简单说一下 embedview,内嵌视图 TemplateRef，内嵌视图创建模板，存有指令宿主元素模板 viewContainer,视图容器,view列表 viewcontainerRef,描绘视图容器，用于管理container,可同时创建内嵌view和组件视图，类里有不同的方法来创建，还有一个container的锚点，用于指定容器，可当做列表的头地址，新创建的view一个个作为兄弟成员存放，方便管理；类中injector存有TemplateRef 几个概念的大概关系如下：","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-管道","date":"2017-07-27T17:24:09.000Z","path":"2017/07/28/angular-pipe/","text":"管道是什么简单来说，是一种值转换器，用于在模板中对变量或数据进行转换后显示，好比数据输入进入一个管道，得到期望的数据输出，示意图：其实，在本质上，就是把一些通用的转换函数封装成管道类，供各个组件模块在应用中实例化使用，比如：字符串转化成大写/数字四舍五入等 使用方法输入值 | 管道：参数输入值流向管道进行处理，并返回处理后的数据| 是管道操作符，熟悉C++的同学可理解管道类的一种运算符重载，赋予它特殊的作用，虽然实际可能只是函数参数的重载管道可带参数值，用于指导数据的处理方式，比如： {{ birthday | date:\"MM/dd/yy\" }} 常用的管道常用内置管道：DatePipe、UpperCasePipe、LowerCasePipe、CurrencyPipe、JsonPipe和PercentPipe等，看名字就能知道各个管道的作用，点击这里进入API文档，搜索pipe可学习更多内置管道多个可选参数管道可以接受任何数量的可选参数来对它的输出进行微调，在管道名后面添加一个或者多个参数，参数间使用冒号( : )隔开，比如 {{data | currency:'EUR'}} {{data | slice:1:5}} 参数可以是字符串常量和组件属性变量，我们可以在组件里利用属性控制显示的格式规则链式调用多个管道链式调用，将从左至右顺序执行，最终的效果时各个管道效果的叠加 {{ birthday | date:'fullDate' | uppercase}} 自定义管道管道作用：存储单位转化器，输入为mb，如果输入小于1,显示kb；小于1024，显示MB;大于1024，显示GB;其他输入值或非数字输入，显示error import { Pipe, PipeTransform } from &apos;@angular/core&apos;; @Pipe({ name: &apos;transverter&apos; }) export class TransverterPipe implements PipeTransform { transform(value: any, args?: any): any { if(isNaN(value)) { return &apos;error&apos; } let tempValue = +value; if(tempValue &lt; 0) { return &apos;error&apos;; } else if(tempValue &lt; 1) { tempValue *= 1024; return tempValue + &apos;KB&apos;; } else if(tempValue &lt; 1024) { return value + &apos;MB&apos;; } else { tempValue = tempValue/1024; return tempValue + &apos;GB&apos;; } } } 管道类只要继承PipeTransform接口，实现transform方法即可，其他第一个参数value是输入数据，后面的args是可选参数，使用管道 &lt;div&gt; &lt;label&gt;请输入： &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot; [(ngModel)]=&quot;inputValue&quot;&gt; &lt;span&gt;MB&lt;/span&gt; &lt;/div&gt; &lt;p&gt;使用管道转换后： {{inputValue | transverter}}&lt;/p&gt; 效果： 管道的变更检测一般情况下，管道对输入数据的变更检测属于纯检测，相应的管道叫纯管道；相应的，非纯管道执行非纯的变更检测策略(1) 纯检测只对原始类型值(String、Number、Boolean、Symbol)的更改进行检测， 或者对对象引用(Date、Array、Function、Object)的更改变化进行检测，而对于对象内的成员值变化不做检测比如，有数组A[10],如下使用管道 let arrayData = A[10]; {{arrayData | PipeName}} 如果数组内成员的值发生变化，纯检测检测不到变更，应为数组引用并无变化使用纯检测方式的管道是纯管道，定义时元数据如下设置： @Pipe({ name: &apos;flyImpure&apos;, }) 或 @Pipe({ name: &apos;flyImpure&apos;, pure: true }) (2) 非纯检测对输入值和数据成员都进行检测，包括组合对象的成员变更，但是每个变更检测周期都会触发检测，次数多，代价较大使用非纯检测方式的管道是非纯管道，定义时元数据如下设置： @Pipe({ name: &apos;flyingHeroesImpure&apos;, pure: false }) 两种管道的定义和使用方式相同，只是变更检测方式不同而已 管道的替代品(1) 使用纯管道实现替代非纯管道由于非纯管道的变更检测次数频繁，代价大，所以一般不会使用它，在需要用到非纯管道的场景，我们也可以用在组件内使用的时候进行特别的设计，使得纯管道也能达到预期效果，比如： let arrayData = A[10]; arrayData = clone(arrayData); {{arrayData | PipeName}} (2) 管道的替代品管道作用就是数据转化，这些工作都可以放在组件内完成，或者定义服务来做，服务也能用来备多个组件共享 其他，一些好东西：1 . Date和Currency管道需要ECMAScript国际化（I18n）API，但Safari和其它老式浏览器不支持它，该问题可以用垫片（Polyfill）解决 &lt;script src=&quot;https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en&quot;&gt; &lt;/script&gt; 2 . 纯管道与纯函数：纯函数是指在处理输入并返回结果时，不会产生任何副作用的函数。 给定相同的输入，它们总是返回相同的输出,纯管道必须总是用纯函数实现 3 . 非纯AsyncPipe,AsyncPipe接受一个Promise或Observable作为输入，并且自动订阅这个输入，最终返回它们给出的值 4 . 在多种值绑定语法中，Angular通过变更检测过程来查找绑定值的更改，并在每一次JavaScript事件之后运行：每次按键、鼠标移动、定时器以及服务器的响应。这可能会让变更检测显得很昂贵，但是Angular会尽可能降低变更检测的成本","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-生命周期钩子","date":"2017-07-23T14:58:58.000Z","path":"2017/07/23/angular-lifecysle-hook/","text":"在开发angular应用书写组件或者指令的时候，我们从来没有去手动的new或者deletet来管理它们的实例，angular系统管理着这一切组件/指令像普通的事物一样，有着自己的声明周期：生，变更，销毁..等等，这个过程有angular自动管理着 生命周期钩子生命周期显而易见，但是当用户想在这个过程中做点什么呢？于是angular便在生命过程中的关键时间点上提供了相应的介入接口和钩子方法，让用户可以介入其中两个概念： 接口,生命周期的暴露点，开发介入点，比如初始化接口：OnInit 钩子，接口对应的函数方法，供开发使用，只要实现相应的钩子方法即看介入对应的生命周期点，比如初始化钩子：ngOnInit() 接口和钩子是一一对应的，钩子方式是：ng接口名，比如OnInit和ngOnInit()，在实现时继承相应接口并实现对应钩子函数即可，当然，接口继承并非强制型的，可以直接实现钩子函数，当清晰起见，最后先继承接口再实现钩子 钩子在组件和指令实例的生命周期里，有多个不同的生命点，angular都为其设置了接口和钩子，按照时间先后有 生命点接口 生命周期钩子 调用方式 OnChanges ngOnChanges() 简单输入变量本值发生变化时调用，第一次调用在OnInit之前 OnInit ngOnInit（） 初始化时调用 DoCheck ngDoCheck（） 周期更改检测，每次变更周期都会调用 AfterContentInit ngAfterContentInit（） 内容完成初始化投影后调用 AfterContentChecked ngAfterContentChecked（） 紧跟上一条完成初始化投影后调用，以及每次变更周期在DoCheck之后调用 AfterViewInit ngAfterViewInit（） 组件和子组件完成视图初始化时调用 AfterViewChecked ngAfterViewChecked（） 紧跟上一条完成组件和子组件完成视图后调用，每次变更周期在AfterContentChecked之后调用 OnDestroy ngOnDestroy（） 销毁时调用 生命周期各个钩子的调用都在构造函数之后 生命钩子的使用（1）OnInit实现组件初始化时需要作的复杂逻辑处理，比如和服务端进行数据交互等，保持构造函数的简单，方便测试 （2）OnDestroy实例销毁时调用，用于在组件或指令销毁时的资源回收，比如：取消可观察对象的订阅，停止定时器等，特别时调用第三方库时的内存回收一个特别的例子，使用echart等第三方库封装图表控件的时候，在初始化图表后，销毁实例时务必调用相关借口释放内存，否则浏览器内存泄露，会变慢，这些工作一般都放在ngOnDestroy（）里来做 （3）OnChanges一般用于父子组件的交互和通讯，可用于子组件对输入变量的变更检测，以便采取一定的行动，当然变更检测能检测到的也只是常规变量引用的值变化，对于对象/组件这种结构型变量的成员变化则无法检测 （4）DoCheck每个变更周期都会调用，可用于检测各种变量的变化，但调用次数频繁，且大部分是无用调用，所以使用时需谨慎，实现逻辑需简单 （5）AfterViewInit一般使用于完成子组件初始化后需要做的工作","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular/cli-命令集","date":"2017-07-23T13:52:01.000Z","path":"2017/07/23/angular-cli-comand/","text":"Angular CLI是一个命令行界面工具，它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布等使用Angular-CLI工具可以快速创建代码框架，减少重复性开发的工作量，而且创建的应用和文件符合风格指南的推荐风格，开发者可以从中获益 基本命令查询版本,获取帮助 ng help ng -v 新建项目，启动应用 ng new projectName cd projectName ng serve --open 指定主机和端口号启动 ng serve --host 0.0.0.0 --port 4201 --open 工具支持相对目录形式的创建命令，比如,当前所处目录/home/app： ng g component login //在/home/app目录下创建 ng g component login ../my //在/home/my目录下创建 ng g component login AA //在/home/app/AA目录下创建 核心命令ng newng new my-app默认生成同名目录，并初始化一个angular应用框架Option选项： --directory (简写:-dir) ，指定新建项目的目录名，比如：ng new my-app -dir AAA;不指定则默认以应用名命名目录 –dry-run (简写:-d) ，默认值: false，生成项目后立即run起来，列出所有生成的项目文件 –inline-style (简写: -is) ，默认不加时为false，，指定生成应用的组件为行内样式，即样式表位于元数据的styles[]内 –inline-template (简写: -it) ，默认不加时为 false，指定生成应用的组件为行内模板，即模板位于元数据的templates[]内 –minimal，默认值: false，创建最小化APP –prefix (简写: -p) 默认: app，指定生成文件的选择器selector的前缀，也可在.angular-cli.json文件中修改 –routing， 默认不加时为 false，指定生成相应的路由模块 –skip-commit (简写: -sc) 默认不加时为 false，指定忽略掉应用提到到库 –skip-git (简写: -sg) 默认不加时为 false，指定忽略掉初始化git仓库 –skip-install (简写: -si) 默认不加时为: false，指定忽略掉安装packages –skip-tests (简写: -st) 默认不加时为: false，指定忽略掉安装测试文件spec/e2e –source-dir (简写: -sd) 默认值: src，指定生成项目的源文件目录名，也可在.angular-cli.json (apps[0].root)中修改 –style，默认值: css，指定css文件类型（css/scss/less/sass/styl (stylus)），也可在文件.angular-cli.json (defaults.styleExt)中修改 –verbose (简写: -v)， 默认不加时为: false，生成时输出log日志 ng serveng serve编译应用并启动web服务Option选项： --host (简写: -H)， 不加时的默认值: localhost，指定启动的主机 –hmr，不加时的默认值: false，是否启动热模块替换 –live-reload (简写: -lr)，不加时的默认值: true，是否在页面变更时重新载入 –public-host (简写: –live-reload-client)，说明浏览器使用的URL –disable-host-check，默认值: false，不检测已连接的host –open (简写: -o)， 不加时默认值: false，指定启动后自动打开浏览器呈现 –port (简写: -p)， 默认值 4200，指定服务的监听端口 –ssl，使用HTTPS –ssl-cert (简写: -)，默认值SSL: –ssl-key，指定使用 serving HTTPS的SSL key –aot，指定进行预编译 –base-href (简写: -bh)，指定应用项目的基准路径,指的是其他应用文件现对于index.html的相对路径，在.angular-cli.json文件可设置根目录和index的路径，如root/src/index,可设-bh ../ –deploy-url (简写: -d)，指定文件部署的URL –environment (简写: -e)，定义编译环境 –extract-css (简写: -ec)，指定从全局样式表抽取样式 –i18n-file，使用i18n国际化 –i18n-format，指定–i18n-file国际化文件的格式 –locale，Locale to use for i18n. –output-hashing (简写: -oh) ，定义the output filename cache-busting hashing mode. Possible values: none, all, media, bundles –output-path (简写: -op) ，指定输出文件的路径 –poll，Enable and define the file watching poll time period (milliseconds) . –progress (简写: -pr)， 默认值: true，是否显示构建过程 –sourcemap (简写: -sm, sourcemaps)，Output sourcemaps. –target (简写: -t, -dev, -prod) 默认值: development，指定编译方式 –vendor-chunk (简写: -vc)，默认值: true，Use a separate bundle containing only vendor libraries. –verbose (简写: -v)， 默认值: false，生成时输出log日志 –watch (aliases: -w)，添加后文件变更会触发重新构建 ng generateng generate 类型 文件名 或 ng g 类型 文件名帮助开发者生成开发文件，类和相应代码骨架，比如：模块，组件，指令等，方便快捷开发，下面一行命令将自动生成组件的目录，和相关的css/ts/html文件 ng g component my-comp （1） moduleng g module module_name生成特性模块Option选项： --app (简写: -a)， 默认值: 1st app –flat，指定是否新建同名目录存放模块文件ng g module 或 ng g module –flat=false ： 新建同名目录ng g module –flat或 ng g module –flat=true : 不新建同名目录 –module (简写: -m)，说明模块在哪导入 –spec，指定是否连带创建spec测试文件ng g module 或 ng g module –spec=false： 同步创建specng g module –spec 或 ng g module –spec=非false: 不创建同名spec –routing，指定是否连带创建路由模块，forChild()ng g module 或 ng g module –routing=false： 不同步创建路由模块ng g module –routing 或 ng g module –routing=非false : 创建路由模块 （2） componentng g component生成组件Option选项： --app (简写: -a) 默认值: 1st app –change-detection (简写: -cd)，不知道什么用 –flat， 默认值: false，指定是否新建组件目录ng g component 或 ng g component –flat=false: 新建目录ng g component –flat 或 ng g component –flat=true: 不新建目录 –export，默认值: false，指定是否公开该组件ng g component 或 ng g component –export=false: 不公开ng g component –export 或 ng g component –export=true: 公开 –inline-style (简写: -is)，默认值: false，指定组件是否行内样式ng g component 或 ng g component -is=false: 不是行内样式ng g component -is 或 ng g component -is=true: 是行内样式 –inline-template (简写: -it)， 默认值: false，指定组件是否行内模板ng g component 或 ng g component -it=false: 不是行内模板ng g component -it 或 ng g component -it=true: 是行内模板 –module (简写: -m)，指定是否更新模块，默认更新 –prefix，指定是否去掉组件selector选择器的前缀ng g component 或 ng g component –prefix=false: 不加前缀ng g component –prefix 或 ng g component –prefix=true: 默认加前缀 –skip-import，默认值: false，Allows for skipping the module import. –spec，指定是否连带创建spec测试文件ng g component –spec=false: 不创建specng g component –spec=true 或 ng g component –spec 或 ng g component: 创建spec –view-encapsulation (简写: -ve)，Specifies the view encapsulation strategy 命令生成的组件默认更新于距离最近的module模块的declares数组里，比如当前所处目录为：/app/main/login/,生成组件后自动注册到本目录的模块中，如果本目录下无模块，则查找上一层目录的模块进行注册，指导根模块 （3） directiveng g directive name用于生成属性指令相关文件和类 ，选项使用方式基本和component类似Option选项： --app (简写: -a) 默认值: 1st app –export default value: false –flat，ng g component –flat=false: 新建目录，其他情况均不新建 –module (aliases: -m) –prefix –skip-import –spec 生成的指令类默认是这样的 mport { Directive } from &apos;@angular/core&apos;; @Directive({selector: &apos;[appA]&apos;}) export class ADirective { constructor() { } } （4） pipeng g pipe name用于生成管道相关文件和类 ，选项使用方式和directive类似Option选项： --app –export –flat –module (aliases: -m) –skip-import –spec 生成的管道类默认是这样的 import { Pipe, PipeTransform } from &apos;@angular/core&apos;; @Pipe({ name: &apos;my&apos;}) export class MyPipe implements PipeTransform { transform(value: any, args?: any): any { return null; } } （5） serviceng g service name用于生成服务相关文件和类 ，选项使用方式和directive类似Option选项： --app (aliases: -a) –flat –module (aliases: -m) –spec 生成的可注入服务默认是这样的 import { Injectable } from &apos;@angular/core&apos;; @Injectable() export class LoginService { constructor() { } } （6） guardng g guard name生成路由守卫类和相关文件Option选项： --app –flat –module (aliases: -m) –spec 生成的守卫类默认是这样的 import { Injectable } from &apos;@angular/core&apos;; import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from &apos;@angular/router&apos;; import { Observable } from &apos;rxjs/Observable&apos;; @Injectable() export class AdminGuard implements CanActivate { canActivate( next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean { return true; } } （7） classng g class name生成类Option选项： --app –spec 生成的类默认是这样的 export class Hero { } （8） interfaceng g interface name typeOption选项： --app type 生成的接口默认是这样的 export interface Name { } （） enumng g enum nameOption选项： --app 生成的enum默认是这样的 export enum HERO { } ng lintng lint命令使用应用配置的tslint规则文件进行lint检查ng lint命令使用应用配置的tslint规则文件进行lint检查Option选项： --fix, 默认值: false，指定检查时是否同步修正lint错误 –force，默认值 false，是否强制检查失败加上后就说有lint错误也成功 –type-check，默认值: false，是否类型检查 –format (简写: -t), 默认值: prose,指定lint输出文件格式，有下列选择：prose, json, stylish, verbose, pmd, msbuild, checkstyle, vso, fileslist ng testng test编译应用后生成输入文件，并运行测试UT ng e2eng e2e命令部署应用并运行e2e测试用例 ng buildng build编译应用并生成目标文件，一般存放于dist/ directory下面命令是等效的 ng build --target=production --environment=prod ng build --prod --env=prod ng build --prod 下面也是等效的 ng build --target=development --environment=dev ng build --dev --e=dev ng build --dev ng build 而已编译时修改index.html配置的基准路径 ng build --base-href /myUrl/ ng build --bh /myUrl/ 下面时两种模式编译默认携带的选项–dev模式： –aot false；–environment dev；–output-hashing media；–sourcemaps true；–extract-css false；–prod模式：–aot true；–environment prod；–output-hashing all；–sourcemaps false；–extract-css true；Options选项： aot， app base-href deploy-url environment extract-css i18n-file i18n-format locale output-hashing output-path delete-output-path poll progress sourcemap stats-json target vendor-chunk verbose watch show-circular-dependencies ng get/ng setng get获取配置文件的内容ng set设置配置文件的内容比如： ng get angular-cli.json //获取整个文件内容 ng get app.name //获取文件内容中app的name属性值 ng set app.name myApp //修改文件内容中app的name属性值 ng docng doc [search term]命令将自动在浏览器打开官方文档angular.io，并调到指定字段处 ng ejectng ejectejects your app and output the proper webpack configuration and scripts ng xi18nng xi18n从应用的默版中收集i18n国际化的信息","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular/cli-安装部署(ubuntu环境)","date":"2017-07-23T13:51:24.000Z","path":"2017/07/23/angular-cli-install-deploy/","text":"安装angular/cli1. npm普通方式(1). 安装升级nodejs进入nodejs官网获取所需的版本，鼠标浮动在相应版本上获取下载路径，本机获取的版本时linux-64的：https://nodejs.org/dist/v6.11.1/node-v6.11.1-linux-x64.tar.xz使用wget下载nodejs包 /home$ wget https://nodejs.org/dist/v6.11.1/node-v6.11.1-linux-x64.tar.xz /home$ tar xvf node-v6.11.1-linux-x64.tar.xz 添加软连接 /home$ sudo ln -s /home/node-v6.11.1-linux-x64/bin/node /usr/local/bin/node /home$ sudo ln -s /home/node-v6.11.1-linux-x64/bin/npm /usr/local/bin/npm 查看版本号： /home$ node -v v8.0.0 /home$ npm -v 5.0.0 (2). 部署angular/cli全局安装angular/cli，等待安装完成 /home$ npm install -g @angular/cli 创建链接 /home$ sudo ln -s /home/node-v6.11.1-linux-x64/bin/ng /usr/local/bin/ng ng -v查看是否安装成功，成功则有版本信息 注意：如果如果之前已存在或安装过，需先清理npm uninstall -g angular-clinpm uninstall –save-dev angular-clinpm cache cleannpm uninstall -g @angular/clinpm cache cleannpm install -g @angular/cli@latest重新安装本地文件rm -rf node_modules distnpm install –save-dev @angular/cli@latestnpm install 2. cnpm普通方式使用为国内程序员定制的cnpm安装更为方便 npm i -g cnpm cnpm i -g @angular/cli 如果如果之前已存在或安装过，需先清理 npm uninstall -g angular-cli npm cache clean npm prune 试用angular/cli通过创建一个新项目来试验下刚刚安装的angular/cli工具打开终端窗口，运行命令生成新的项目和应用程序框架：安装依赖包 cd my-app npm install 启动服务 ng serve --open ng serve该命令启动服务器，监视您的文件更改，重新构建应用程序;添加–open选项将在构建成功后自动打开您的浏览器进行呈现如果想让加载的包更小，可以添加选项prod ng serve --prod --open 效果相同：","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-属性指令","date":"2017-07-20T17:26:02.000Z","path":"2017/07/21/angular-attr-directive/","text":"属性型指令是angular中三大指令之一，主要用于改变一个DOM元素的外观或操作行为，比如：可以改变元素的样式和事件响应等，可以像原生属性一样直接使用于标签元素，故此得名本节将会介绍几个最常用的属性型指令： 三大指令：组件，属性指令，结构指令 常用内置属性指令（1）NgClassngClass用于动态添加或移除一组CSS类，从而控制元素的显示效果，通过绑定到NgClass，可以同时添加或移除多个类当然，还有一种动态添加/移除单个类的CSS绑定，也能实现类似效果下面两种写法效果相同 .active { font-size: 36px; background-color: #ff2312; } .deactive { font-size: 16px; background-color: #fffff; } &lt;div [class.active]=&quot;isSpecial&quot; [class.deactive]=&quot;!isSpecial&quot;&gt;binding Class&lt;/div&gt; &lt;div [ngClass]=&quot;{active: isSpecial,deactive: !isSpecial}&quot;&gt;binding Class&lt;/div&gt; 上面当变量isSpecial为true时添加类active，否则添加deactive还可以同时添加或移除多个CSS类，像这样 .special { color: red; } currentClasses = {active: isSpecial,special: isSpecial,deactive: !isSpecial} &lt;div [ngClass]=&quot;currentClasses&quot;&gt;binding Class&lt;/div&gt; （2）NgStylengStyle用于动态内联样式，从而控制元素的显示效果，通过绑定到NgStyle，可以同时设置多个内联样式。当然，还有一种动态单一样式值的样式绑定，也能实现类似效果下面两种写法效果相同 &lt;div [style.font-size]=&quot;isSpecial ? &apos;large&apos; : &apos;small&apos;&quot; &gt; bind styles &lt;/div&gt; &lt;div [ngStyle]=&quot;{&apos;font-size&apos;:isSpecial ? &apos;large&apos; : &apos;small&apos;}&quot; &gt; bind styles &lt;/div&gt; 上面根据变量isSpecial为true或false给元素设置不同的字体大小要同时设置多个内联样式，NgStyle指令更好，像这样 currentStyles = { &apos;font-style&apos;: iscanSave ? &apos;italic&apos; : &apos;normal&apos;, &apos;font-weight&apos;: !isUnchanged ? &apos;bold&apos; : &apos;normal&apos;, &apos;font-size&apos;: isSpecial ? &apos;24px&apos; : &apos;12px&apos; }; &lt;div [ngStyle]=&quot;currentStyles&quot;&gt; bind styles &lt;/div&gt; （3）NgModel（1）使用方式开发输入表单时，通常都要既显示数据属性又要修改这个属性，使用NgModel指令进行双向数据绑定可以简化这种工作，使用方式如下： &lt;input [(ngModel)]=&quot;currentHero.name&quot; name=&quot;input&quot;&gt; 还有导入表单支持模块 import { FormsModule } from &apos;@angular/forms&apos;; 使用此指令需要指定name值。一个表单中可能有多个这样的双向绑定，在Angular内部为这些绑定创建了一些FormControl，并把它们注册到NgForm指令，再将该指令附加到&lt;form&gt;标签，而注册每个FormControl时，就是使用name属性值作为每个双向绑定的键值 （2）跟踪修改和输入验证NgModel指令更够跟踪输入状态，动态给宿主元素添加/移除CSS类，以反映当前状态，我们可以这一特性来修改控件的外观，显示和隐藏消息在输入各个不同状态下添加的类： 被访问过的时候添加ng-touched类，否则添加ng-untouched 值变化了的时候添加ng-dirty类，否则添加ng-pristine 输入值有效的时候添加ng-valid类，否则添加ng-invalid 我么可以重新定义这些CSS类，控制着些状态按照期望来显示，比如： .ng-valid[required] { border-left: 5px solid #42A948; } .ng-invalid:not(form) { border-left: 5px solid #a94442; } 还有，这些css类对应一些只是输入状态的标志位，比如：ng-pristine-&gt;pristine,ng-valid-&gt;valid，可以通过他们来显示/移除输入提示，比如： &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; required [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot; #name=&quot;ngModel&quot;&gt; &lt;div [hidden]=&quot;name.valid || name.pristine&quot; class=&quot;alert alert-danger&quot;&gt; Name is required &lt;/div&gt; 当输入有效或没变更时，隐藏提示；否则，显示提示 （3）双向绑定指令的内部原理在元素层面上，既要设置元素属性，又要监听元素事件变化,普通方式 &lt;input [value]=&quot;name&quot; (input)=&quot;name=$event.target.value&quot;&gt; ngular 为此提供一种特殊的双向数据绑定语法：[(x)]，该语法结合了属性绑定的方括号[x]和事件绑定的圆括号(x) &lt;input [(ngModel)]=&quot;name&quot;&gt; 双向绑定语法实际上是属性绑定和事件绑定的语法糖,Angular将绑定分解成这样： &lt;input [ngModel]=&quot;name&quot; (ngModelChange)=&quot;name=$event&quot;&gt; 当一个元素拥有可以设置的属性x和对应的事件xChange时，解释[(x)]语法就容易的多，而ngModel指令即使通过自己的输入属性ngModel和输出属性ngModelChange隐藏了那些细节 （4）自定义双向绑定指令根据[(x)]语法的特点，可以实现自己双向绑定,使用方式ngModel类似定义子组件： //.ts import { Component, OnInit, EventEmitter, Input, Output } from &apos;@angular/core&apos;; @Component({ selector: &apos;app-test&apos;, templateUrl: &apos;./test.component.html&apos;, styleUrls: [&apos;./test.component.css&apos;] }) export class TestComponent implements OnInit { @Output() myNumberChange = new EventEmitter&lt;any&gt;(); id : any; personList : any[] = [{&apos;id&apos;:1, &apos;name&apos;:&apos;Jack&apos;, &apos;age&apos;:10}, {&apos;id&apos;:5, &apos;name&apos;:&apos;Tom&apos;, &apos;age&apos;:18}, {&apos;id&apos;:8, &apos;name&apos;:&apos;Luccy&apos;, &apos;age&apos;:24}]; constructor() { } @Input() set myNumber(num : any) { this.id = num; } add() { this.id++; this.getPerson(); } des() { this.id--; this.getPerson(); } getPerson() { for(let person of this.personList) { if(person.id === this.id) { this.myNumberChange.emit(person.age); return; } } this.myNumberChange.emit(99); } ngOnInit() { } } //.html &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;form-input-label&quot;&gt;id： &lt;/label&gt; &lt;div class=&quot;form-input-content&quot;&gt; {{id}} &lt;/div&gt; &lt;/div&gt; &lt;button class=&quot;button&quot; (click)=&quot;add()&quot;&gt;增加&lt;/button&gt; &lt;button class=&quot;button&quot; (click)=&quot;des()&quot;&gt;减少&lt;/button&gt; 子组件通过输入变量myNumber获取值，处理后使用输出事件myNumberChange返回给宿主结果父组件在用时可以使用双向绑定的语法方式： //login.comonent inputNum : any = 0; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;form-input-label&quot;&gt;输入变量值： &lt;/label&gt; &lt;div class=&quot;form-input-content&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;inputNum&quot; [(ngModel)]=&quot;inputNum&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;app-test [(myNumber)]=&quot;inputNum&quot;&gt;&lt;/app-test&gt; &lt;p&gt;返回的值： {{inputNum}}&lt;/p&gt; 如下时两个瞬间大概是点击“增加”，组件id变为5，并返回父组件变更了inputNum的值为18，inputNum变更后反过来又把值传入给子组件输入变量 自定义属性指令属性型指令可以同时实现元素多个普通属性所能达到效果的集合，这是属性指令比普通属性的优势。在开发过程中可以根据需要自定义属性型指令，避免元素上过多的属性添加下面的例子需要实现一个文本框，要求：只能呈现数字，可以通过鼠标点击增长/减少数值，可以手动输入数值，不能粘贴数值，能限制数值范围，输入时不能输入超出范围的数值，不能输入非数字的字母,输入聚焦时底色变更；以上可以通过一个属性型指令来实现通过@Directive装饰器来定义指令 import { Directive, ElementRef,HostListener,Input } from &apos;@angular/core&apos;; @Directive({ selector: &apos;[myInputNumber]&apos; }) export class InputNumberDirective { @Input(&apos;myInputNumber&apos;) min_number: any; constructor(private el: ElementRef) { } @HostListener(&apos;focusin&apos;) onFocusIn() { this.el.nativeElement.style.backgroundColor = &apos;yellow&apos;; } @HostListener(&apos;focusout&apos;) onFocusOut() { this.el.nativeElement.style.backgroundColor = &apos;#ffffff&apos;; } @HostListener(&apos;keyup&apos;) onkeyup() { if(!Number(this.el.nativeElement.value) || (Number(this.el.nativeElement.value) &lt; this.min_number)) { this.el.nativeElement.value = this.min_number; } } @HostListener(&apos;paste&apos;) onPaste() { return false; } @HostListener(&apos;keypress&apos;) onkeypress() { return true; } @HostListener(&apos;keydown&apos;) onkeydown() { return true; } } 使用该属性指令的父组件 //loginComponent.ts import { Component, OnInit } from &apos;@angular/core&apos;; @Component({ selector: &apos;app-login&apos;, templateUrl: &apos;./login.component.html&apos;, styleUrls: [&apos;./login.component.css&apos;] }) export class LoginComponent implements OnInit { number : any = 0; minNumber : any = 3; constructor() { this.number = this.minNumber; } ngOnInit() { } aggreNum() { this.number++; } deagreNum() { if(this.number &gt; this.minNumber) { this.number--; } } minMunChange() { this.number = this.minNumber; } } //loginComponent.html &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;form-input-label&quot;&gt;最小值： &lt;/label&gt; &lt;div class=&quot;form-input-content&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;inutMinNumber&quot; [(ngModel)]=&quot;minNumber&quot; (ngModelChange)=&quot;minMunChange()&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;form-input-label&quot;&gt;请输入： &lt;/label&gt; &lt;div class=&quot;form-input-content&quot;&gt; &lt;input type=&quot;text&quot; [myInputNumber]=&quot;minNumber&quot; name=&quot;inutNumber&quot; [(ngModel)]=&quot;number&quot;&gt; &lt;/div&gt; &lt;div class=&quot;input-number&quot;&gt; &lt;div class=&quot;input-aggre&quot; (click)=&quot;aggreNum()&quot;&gt;+&lt;/div&gt; &lt;div class=&quot;input-desgre&quot; (click)=&quot;deagreNum()&quot;&gt;-&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; （1）angular会为在指令使用时创建一个指令控制器类的实例，并把angular的ElementRef和Renderer注入进构造函数，ElementRef是一个服务，它赋予我们通过它的nativeElement属性直接访问 DOM 元素的能力（2）Renderer服务允许通过代码设置元素的样式（3）使用HostListener装饰器添加两个事件处理器（4）使用简单语法，[myInputNumber]在这里同时实现了两点：把指令应用到了宿主元素上，并且通过属性绑定设置了输入变量指令使用的效果大概如下 附录,一些好东西1 . 组件自己的模板可以绑定到组件的任意属性，不需要使用了@Input装饰器，因为Angular把组件的模板看做从属于该组件的，它们之间相互信任；但是组件或指令不应该盲目信任其它组件或指令， 因此组件或指令的属性默认是不能被绑定的，从Angular绑定机制的角度来看，它们是私有的，而当添加了@Input时，它们变成了公共的，只有这样，它们才能被其它组件或属性绑定 2 . 如果有两个同名指令，都叫做HighlightDirective，只要在 import 时使用as关键字来为第二个指令创建个别名即可，比如： import {HighlightDirective as myHighlight} from &apos;&apos;; 3 . EventEmitter自定义事件EventEmitter用于触发自定义事件，指令或子组件创建一个EventEmitter实例，并且把它作为属性暴露出来，调用EventEmitter.emit(payload)来触发事件，可以传入任何东西作为消息载荷。 父指令通过绑定到这个属性来监听事件，并通过$event对象来访问载荷，下面例子： //hero-detail.component.html &lt;div&gt; &lt;img src=&quot;{{heroImageUrl}}&quot;&gt; &lt;span [style.text-decoration]=&quot;lineThrough&quot;&gt; {{prefix}} {{hero?.name}} &lt;/span&gt; &lt;button (click)=&quot;delete()&quot;&gt;Delete&lt;/button&gt; &lt;/div&gt;` //hero-detail.component.ts deleteRequest = new EventEmitter&lt;Hero&gt;(); delete() { this.deleteRequest.emit(this.hero); } 组件定义了deleteRequest属性，它是EventEmitter实例。 当用户点击删除时，组件会调用delete()方法，让EventEmitter发出一个Hero对父组件绑定这个事件: &lt;hero-detail (deleteRequest)=&quot;deleteHero($event)&quot; [hero]=&quot;currentHero&quot;&gt; &lt;/hero-detail&gt; 当deleteRequest事件触发时，Angular 调用父组件的deleteHero方法， 在$event变量中传入要删除的英雄","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-组件样式表","date":"2017-07-19T17:43:48.000Z","path":"2017/07/20/angular-component-styles/","text":"在angular应用中可以使用所有的CSS样式来修饰我们的模板元素，渲染我们的页面，还可以把样式的有效范围限制在组件模板中 样式在组件的使用方式（1）在模板中直接使用//外联样式文件 &lt;link src=&quot;common.css&quot;&gt; //模板内样式 &lt;style&gt; h1 { font-size: 24px; color: red; } &lt;/style&gt; //元素内联样式 &lt;div style=&quot;display:inline;&quot;&gt;&lt;/div&gt; （2）在组件元数据配置//通过URL路径加载CSS文件 @Component({ selector: &apos;app-root&apos;, styleUrls: [&apos;./app.component.css&apos;] }) //通过CSS字符串数组 @Component({ selector: &apos;app-root&apos;, styles: [&apos;h1 {color: green;}&apos;] }) //通过模块打包器载入CSS字符串 @Component({ selector: &apos;app-root&apos;, styles: [require(&apos;./app.component.css&apos;)] }) 第三种与第二种实例，都是设置的styles数据，只不过后者是直接加载的css字符串，不用手动在数据里写，推荐第一种写法 样式限定范围在组件angular默认采用Emulated仿真式模式来设置组件元数据的视图封装模式仿真式模式，是通过预处理CSS 代码来模拟Shadow DOM的行为，把CSS 样式的有效范围局限在组件视图中。就是“只进不出”，全局样式能够在组件模板中使用生效，但本组件的CSS样式不能正常在组件外部使用究其内部，其实只是angular对组件的CSS/模板进行预处理后，在组件模板元素上添加特定的属性，并且同时在CSS也添加相应的属性，来达到限制范围在目的，比如： //appComponen.ts @Component({ selector: &apos;app-root&apos;, templateUrl: &apos;./app.component.html&apos;, styleUrls: [&apos;./app.component.css&apos;] }) export class AppComponent { title = &apos;app&apos;; } //appComponen.html &lt;div style=&quot;text-align:center&quot;&gt; &lt;h1 class=&quot;HAHA&quot;&gt; Welcome to {{title}}! &lt;/h1&gt; &lt;img width=&quot;300&quot; src=&quot;data:image/svg+xml“&gt; &lt;/div&gt; &lt;h2&gt;Here are some links to help you start: &lt;/h2&gt; //appComponen.css .HAHA { color: red; } 运行应用偶打开浏览器查看元素 特殊选择器（1）:host {}表示组件的宿主元素，以宿主元素的属性来控制本组件模板内的样式表现，但是不能控制宿主的样式，比如组件Logincomponent的元数据如下： //logincomponent.ts import { Component, OnInit } from &apos;@angular/core&apos;; @Component({ selector: &apos;app-login&apos;, templateUrl: &apos;./login.component.html&apos;, styles: [&apos;:host(.AAA) p { color: orange;font-size: 36px;}&apos;] }) export class LoginComponent implements OnInit { constructor() { } } //logincomponent.html &lt;p&gt; login works! &lt;/p&gt; //父组件调用 &lt;app-login&gt;&lt;/app-login&gt; 组件Login的宿主元素就是它的选择器组成的&lt;app-login&gt;&lt;/app-login&gt;，此时组件样式是没有效果的要想生效必须在宿主元素中加上条件 &lt;app-login class=&quot;AAA&quot;&gt;&lt;/app-login&gt; 效果： （2）:host-context {}表示组件的祖先元素，不限于宿主元素，以祖先元素的属性来控制本组件内的样式表现，不能控制祖先宿主的样式还是上面那个例子，在父组件使用时改成 @Component({ selector: &apos;app-login&apos;, templateUrl: &apos;./login.component.html&apos;, styles: [&apos;:host-context(.AAA) p { color: orange;font-size: 36px;}&apos;] }) export class LoginComponent implements OnInit { constructor() { } } //父组件调用 &lt;div&gt; &lt;app-login&gt;&lt;/app-login&gt; &lt;/div&gt; 其中div和app-login都是组件的祖先宿主宿主元素，适用此选择器，此时组件样式时不生效的，要想生效需修改如下 &lt;div class=&quot;AAA&quot;&gt; &lt;app-login&gt;&lt;/app-login&gt; &lt;/div&gt; 或 &lt;div&gt; &lt;app-login class=&quot;AAA&quot;&gt;&lt;/app-login&gt; &lt;/div&gt; （3）/deep/ &gt;&gt;&gt;组件样式默认只在本组件内生效，CSS定义时加上这个生效范围会扩大到其子组件的模板视图这里说的子组件指的是在组件模板内直接使用其他组件的选择器的，比如上面例子的组件login就是其调用者的子组件这么写 :host &gt;&gt;&gt; h1 {color:red;} 或 :host /deep/ h1 {color:red;} 表示本组件的h1适用，甚至子组件的h1也适用于这个选择器","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-路由器","date":"2017-07-16T16:56:10.000Z","path":"2017/07/17/angular-router/","text":"路由与导航是组织多页面应用的基本需求，也是angular最重要的几个特性之一。Angular提供了强大的路由机制来保证页面之间的跳转，根据配置的地址导航对应视图页面，并将地址值更新到浏览器地址栏中，将应用的所以页面有机的组织在了一起 路由树路由树是angular三大基本树结构之一，有着自己的配置方式，一般以单独的路由模块提供，伴随着模块的导入和导出，形成树状路由，如下图时一个典型的伴随着模块的组织而形成的路由树状结构： 路由路径导航模块直接导入之后，相应的路由模块的配置与准入模块的路由进行了合并，成为树的同级枝丫，下面是根据上一节路由树所描绘处理的导航示意图，以及形成的URL与组件的对应关系：如图所示，每一个url路径对应一个组件，路由器会根据在浏览器地址栏输入的地址或者代码里命令形式导航的地址去匹配相应的url，渲染对应组件的视图 路由配置关于angular路由请点击这里查看官方指导文档基本的路由配置就几个步骤： 1. 基准地址配置angular使用pushState方式构造url，必须设置基准地址，pushState才能正常工作设置方式： 1 ). 如果app目录是应用的根目录，可以在index.html设置：&lt;base href=&quot;/&quot;&gt;2 ). 在根模块中使用适当的APP_BASE_HREF值配置provide路由器，不过这种配置方式，应用中图片、CSS文件等的引用要使用绝对路径，比如: providers: [{provide: APP_BASE_HREF, useValue: &apos;/my/app&apos;}] 配置作用： 告诉路由器该如何合成导航用的url 方便引用CSS文件、脚本和图片，浏览器会用基准地址的值作为相对URL的前缀 2. 路由列表配置路由列表以路由模块的方式来提供，下面是一个典型的简单路由列表： import { NgModule } from &apos;@angular/core&apos;; import { RouterModule, Routes } from &apos;@angular/router&apos;; import { CrisisListComponent } from &apos;./crisis-list.component&apos;; import { HeroListComponent } from &apos;./hero-list.component&apos;; import { PageNotFoundComponent } from &apos;./not-found.component&apos;; const appRoutes: Routes = [ { path: &apos;crisis-center&apos;, component: CrisisListComponent }, { path: &apos;heroe/:id&apos;, component: HeroComponent }, { path: &apos;&apos;, redirectTo: &apos;/heroes&apos;, pathMatch: &apos;full&apos; }, { path: &apos;**&apos;, component: PageNotFoundComponent } ]; @NgModule({ imports: [ RouterModule.forRoot(appRoutes) ], exports: [ RouterModule ] }) export class AppRoutingModule {} （1）路由项以{path:,component:}为基本定义格式，保存路由的注册映射表，当浏览器的URL变化或代码中直接导航到某一url路径时，路由器就会翻出映射表,激活或生成对应组件的实例，用来显示视图，更新url到地址栏（2）path不需要以斜杠（/）开头，路由器会为解析和构建最终的URL（3）路由匹配是第一次最先匹配即停止原则，所以声明顺序很重要，建议顺序：具体路由-&gt;空路由-&gt;通配路由，通配path(**)可放置在最后作为错误url的默认页面提示（4）注册路由方式：RouterModule.forRoot只能用于根模块；RouterModule.forChild用于特性模块 3. 路由导航导航的声明方式有链接式和命令式导航两种： 链接式，routerLink=&quot;/hero/undefined&quot; 命令式，this.router.navigate([&#39;/hero&#39;, hero.id]) 假如要导航到一个英雄的详情页面，下面3中方式是等效的 &lt;button routerLink=&quot;{{'/hero/' + crisis.id}}&quot; routerLinkActive=&quot;Active&quot;&gt; &lt;/button&gt; &lt;button [routerLink]=&quot;[&apos;/hero&apos;, hero.id]&quot; [routerLinkActive]=&quot;[&apos;Active&apos;,&apos;classA&apos;]&quot;&gt;&lt;/button&gt; &lt;button (click)=&quot;gotoDetail()&quot; routerLinkActive=&quot;Active&quot;&gt;&lt;/button&gt; gotoDetail() {this.router.navigate([&apos;/hero&apos;, hero.id]);} （1） routerLinkActive:RouterLinkActive指令属性绑定，用于在路由激活时把CSS类添加到该元素上,反之则移除（2）RouterLinkActive可以绑定到一个CSS类组成的数组，绑定方式有[routerLinkActive]=”[‘A’,’B’]” 或 routerLinkActive=“A B” 4. 路由参数提取(1) 参数提取对象ActivatedRoute，可以通过注入此路由服务来获取路由的路径和参数，它有很多有用的信息： url //路由路径的Observable对象，它的值是一个由路径中各个部件组成的字符串数组 data //该路由提供的data对象的一个Observable对象，还包含从resolve守卫中解析出来的值 params //包含该路由的必选参数和可选参数的Observable对象 queryParams //一个包含对所有路由都有效的查询参数的Observable对象。 fragment //一个包含对所有路由都有效的片段值的Observable对象。 outlet //RouterOutlet的名字，用于指示渲染该路由的位置,对于未命名的RouterOutlet，这个名字是primary routeConfig //与该路由的原始路径对应的配置信息。 parent //当使用子路由时，它是一个包含父路由信息的ActivatedRoute对象 firstChild //包含子路由列表中的第一个ActivatedRoute对象。 children //包含当前路由下激活的全部子路由。 注意：当在组件中订阅一个可观察对象时，我们通常总是要在组件销毁时取消这个订阅,但是也有少数例外情况不需要取消订阅，而ActivateRoute中的各种可观察对象就是属于这种情况。ActivateRoute及其可观察对象都是由Router本身负责管理的。 Router会在不再需要时销毁这个路由组件，而注入进去的ActivateRoute也随之销毁了 （2）提取参数的方式使用可观察对象订阅的方式，下面两种方式效果相同switchMapswitchMap允许你在Observable的当前值上执行一个动作，并将它映射一个新的Observable,然后再使用subscribe方法解析Observable对象获取值 import { ActivateRoute } from ‘@angular/router’; constructor(private route: ActivateRoute) { this.route.params .switchMap((params: Params) =&gt; this.service.getHero(+params[&apos;id&apos;])) .subscribe((hero: Hero) =&gt; this.hero = hero); } subscribe使用subscribe方法直接解析params参数信息，获取数据值 import { ActivateRoute } from ‘@angular/router’; constructor(private route: ActivateRoute) { this.route.params .subscribe((params: Params) =&gt; { this.hero = this.service.getHero(+params[&apos;id&apos;]); }); } 快照如果组件的实例不会被复用，可以使用一次性的快照route.snapshot来简化实现，它提供了路由参数的初始值，可以通过它来直接访问参数，而不用订阅或者添加 import { ActivateRoute } from ‘@angular/router’; constructor(private route: ActivateRoute) { this.hero = this.service.getHero(+this.route.snapshot.params[&apos;id&apos;]); } 注意事项：1）像许多其它rxjs操作符一样，switchMap既可以处理Observable也可以处理Promise发射的值。并且，如果用户重新导航到该路由，并且它正在获取一个英雄时，switchMap操作符还会取消任何正在执行的请求2）默认情况，如果没有访问过其它组件就导航到了同一个组件实例，路由器倾向于复用组件实例,比如：搜索功能，这就需要Observable对象的方法来动态处理 可选参数的定义和提取可选参数是导航期间传送任意复杂信息的理想载体，可选参数不涉及到模式匹配，在表达上提供了巨大的灵活性1）定义方式只要在必要参数之后，通过一个独立的对象来定义可选参数，比如： this.router.navigate([&apos;/heroes&apos;, heroId, { foo: &apos;123&apos; }]); 合成的URL为：/heroes/123456;foo=foo1 ，可选的路由参数在url中没有使用“？”和“&amp;”符号分隔，而是以;和主url相隔2）提取方式 this.heroes = this.route.params .switchMap((params: Params) =&gt; { this.foo = +params[&apos;foo&apos;]; return this.service.getHeroes(); }); 路由视图目标出口的选择理由器在为组件选择显示出口的时候，是以距离最近为原则，就是选择距离组件最近的上层outlet目标进行呈现，比如： { path: &apos;crisis-center&apos;, component: CrisisCenterComponent, children: [ { path: &apos;compose&apos;, component: ComposeMessageComponent }, { path: &apos;&apos;, component: CrisisListComponent, children: [ { path: &apos;:id&apos;, component: CrisisDetailComponent }, { path: &apos;&apos;, component: CrisisCenterHomeComponent } ] } ] } 本例中，组件CrisisCenterComponent和CrisisListComponent的模板中都有outlet出口定义，所以 ComposeMessageComponent将在CrisisCenterComponent的outlet渲染呈现 CrisisCenterHomeComponent和CrisisDetailComponent在CrisisListComponent的outlet呈现； 若距离最近的父组件没有outlet，则往上匹配，在更上一级父组件的outlet；举个例子，如果把path: ‘compose’放在于crisis-center同级，将直接匹配appcomponent的outlet位置；同理，如果放在于CrisisDetail同级作为list的子路由，则将优先匹配CrisisListComponent的outlet位置，不行再往上匹配 相对路由特性模块内部应该优先考试使用相对路由，以减少对上层路由的依赖“目录式”语法 ./或无前导斜线形式是相对于当前级别的。 ../会回到当前路由路径的上一级。 ../导航到一个兄弟路由，先回到上一级，然后进入兄弟路由路径 使用例子： this.router.navigate([crisis.id], { relativeTo: this.route })； this.router.navigate([&apos;../&apos;, { id: crisisId, foo: &apos;foo&apos; }], { relativeTo: this.route }); 使用RouterLink来进行导航，使用相同的链接参数数组，不过不需要提供relativeTo属性，因为ActivatedRoute已经隐含在了RouterLink指令中，下面定义与上面等效： &lt;a [routerLink]=&quot;[crisis.id]&quot;&gt; 最后，一些好东西：1 ) RouterLinkActive指令会基于当前的RouterState对象来为激活的RouterLink切换CSS类,这会一直沿着路由树往下进行级联处理，所以父路由链接和子路由链接可能会同时激活。使用routerLinkActiveOptions属性可以改变这种行为，比如： &lt;a routerLink=&quot;/contact&quot; routerLinkActive=&quot;Active&quot; [routerLinkActiveOptions]=&quot;{exact: true}&quot;&gt; &lt;/a&gt; 如上设置可以限制只有在其URL与当前URL精确匹配时才会激活指定的RouterLink 2 ) 路由器中的一些关键词 Router，路由器，为激活的URL显示应用组件，并管理从组件之间的导航 RouterModule，路由器模块，一个独立的Angular模块，用于提供所需的服务提供商，以及用来在应用视图之间进行导航的指令 Routes，路由数组，数组里每个成员都会把一个URL路径映射到一个组件。 Route，路由成员，定义路由器该如何根据URL模式（pattern）来导航到组件，大多数路由都由路径和组件类构成 RouterOutlet，路由出口，用来标记出路由器该在哪里显示视图 RouterLink，路由链接routerLink，该指令用来把一个可点击的HTML元素绑定到路由，点击带有绑定到字符串或链接参数数组的routerLink指令的元素就会触发一次导航 RouterLinkActiv，活动路由链接routerLinkActive，当HTML元素上或元素内的routerLink变为激活或非激活状态时，该指令为这个HTML元素添加或移除CSS类 ActivatedRoute，激活的路由，为每个路由组件提供提供的一个服务，它包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片（fragment） RouterState，路由器状态，路由器的当前状态包含了一棵由程序中激活的路由构成的树。它包含一些用于遍历路由树的快捷方法 链接参数数组，这个数组会被路由器解释成一个路由操作指南。我们可以把一个RouterLink绑定到该数组，或者把它作为参数传给Router.navigate方法 路由组件，一个带有RouterOutlet的Angular组件，它根据路由器的导航来显示相应的视图 3 ) 特性领域的路由特征： 每个特性都有自己的路由模块。 每个特性区都有自己的根组件。 每个特性区的根组件中都有自己的路由出口及其子路由。 特性区的路由很少（或完全不）与其它特性区的路由交叉 4 ) 多路由出口在模板中，路由器只能支持一个无名主路由出口,但可以有多个命名的路由出口每个命名出口都自己有一组带组件的路由。多重出口可以在同一时间根据不同的路由来显示不同的内容 出口定义: &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;router-outlet name=&quot;popup1&quot;&gt;&lt;/router-outlet&gt; &lt;router-outlet name=&quot;popup2&quot;&gt;&lt;/router-outlet&gt; 配置路由对象： { path: &apos;compose&apos;, component: ComposeMessageComponent, outlet: &apos;popup&apos; } 使用方式： &lt;a [routerLink]=&quot;[{ outlets: { popup: [&apos;compose&apos;] } }]&quot;&gt;Contact&lt;/a&gt; 链接参数数组包含一个只有一个outlets属性的对象，它的值是另一个对象，这个对象以一个或多个路由的出口名作为属性名。 在这里，它只有一个出口名“popup”，它的值则是另一个链接参数数组，用于指定compose路由 注意：当有且只有一个无名出口时，外部对象中的这个outlets对象不是必须的，路由器假设这个路由指向了无名的主出口，并为我们创建这些对象。当路由到一个命名出口时，我们就会发现这个隐藏的真相 关闭命名出口： this.router.navigate([{ outlets: { popup: null }}]); 各个outlet出口独立导航：路由器在导航树中可以对多个独立的分支保持追踪，并在URL中对这棵树进行表达。我们可以添加更多出口和更多路由（无论是在顶层还是在嵌套的子层）来创建一个带有多个分支的导航树， 路由器将会生成相应的URL。通过像前面那样填充outlets对象，我们可以告诉路由器立即导航到一棵完整的树。 然后把这个对象通过一个链接参数数组传给router.navigate方法","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-注入器","date":"2017-07-16T09:16:49.000Z","path":"2017/07/16/angular-Injector/","text":"依赖注入是一种程序设计模式，指的是在应用构建里将所需的服务或者部件委托给第三方厂商提供，自身只关注应用逻辑，需要什么服务只需从厂商请求即可，而不用关心服务具体的创建过程和升级相对于以前大而全的设计方式，这种思路的转变，可以使应用本身和所需的服务相对独立的开发和升级，而不用存在太大的耦合，下面是简单的示意图：在angular里，自带的“依赖注入框架”和注入器就扮演着这样的一个角色，为构建angular应用的服务需求提供了可靠的提供机制，简便了应用的搭建 一. 注入器树注入器树时angular基本树之一，在官方的angular高级文档-多级注入器一章里已经作了相对清晰的讲解，描述的是和另一基本树-组件树平级对应的注入器，组件树里的每一个组件节点都可以拥有自己的注入器，于是便有了这个注入器树，这个很好理解这里不再赘述，这里要描述的是由angular中多个不同类型注入器组成的多级注入器树在angular中，根据注入器的启动时间和使用范围的不同，可划分为以下几种: 根注入器在main.ts里引导启动应用时，即创建了根注入器，整个应用范围内有效；除了根模块的privodes里的供应商直接注册到根注入器之外，直接导入到根模块的其他模块里的供应商也是注册根注入器 模块子注入器指懒加载模块内的注入器，在加载后启动，使用范围限于本模块，供应商注册在子注入器中，包括被导入模块的供应商 组件注入器指组件内的注入器，供应商在组件的privode数组内声明，只在组件和子组件范围内有效，且每个组件实例都有一份属于自己的注入器。在组件级提供服务可以确保组件的每个实例都得到一个自己的、私有的服务实例 多级注入器树由这些不同的注入器构成，树的结构与模块/组件的组织有着相似的层级和对应关系，下图是一个简单的注入器树示意： 二.服务的注入angular应用中配置使用注入服务需要定义可注入服务，注册供应商，服务请求等几个步骤，下面描述一下： 1. 声明可注入服务使用@Injectable()声明可注入服务，Injectable标识一个类可以被注入器实例化，示例如下： import { Injectable } from &apos;@angular/core&apos;; import { HEROES } from &apos;./mock-heroes&apos;; import { Logger } from &apos;../logger.service&apos;; @Injectable() export class HeroService { constructor(private logger: Logger) { } getHeroes() { this.logger.log(&apos;Getting heroes ...&apos;); return HEROES; } } @Injectable()装饰器把一个类标识为注入器实例化的目标，试图实例化没有被标识Injectable的类时，注入器会报错。 2. 注册提供商什么是提供商提供商即服务供应商，提供了依赖值的一个具体的版本，指导注入器如何创建服务。注入器依靠提供商提供的版本来创建服务实例，然后将服务的实例注入组件或其它服务 提供商的种类提供商没有严格的定义，可以有很多种，只要它们能交付一个行为类似的对象即可，比如：类、对象、工厂函数、变量值等 提供商声明(1) 类供应商providers：[{ provide: key令牌, useClass: 对象实例 }] 比如： providers：[{ provide: Logger, useClass: Logger }] providers：[Logger] //简化版 (2) 备选服务供应商使用超类作key令牌，子类作为实例化类，例如： @Injectable() class EvenBetterLogger extends Logger { constructor(private userService: UserService) { super(); } log(message: string) { let name = this.userService.user.name; super.log(`Message to ${name}: ${message}`); } } providers：[{ provide: Logger, useClass: EvenBetterLogger}] (3) 别名服务供应商使用已定义的类作为实例化类，其他类名作key令牌，例如： providers：[NewLogger， { provide: Logger, useExisting: NewLogger}] (3) 值依赖供应商使用一个对象或者变量作为供应商对像，这在一些全局参数配置中有重要的用处，例如： const silentLogger = { logs: [&apos;Silent logger says &quot;Shhhhh!&quot;. Provided via &quot;useValue&quot;&apos;], log: () =&gt; {} }; providers：[{ provide: Logger, useValue: silentLogger}] 注意：供应商在一个注入器中不能重复注册，否则会出现多个相同的实例，这是不被期望的 3. 服务注入请求作为重要的一步是用户如何进行注入请求，因为服务最终是要用于应用中，否则前面的配置都没有什么意义，服务注入分为隐式注入和显式注入两种 （1）隐式注入最常见的注入配置时在我们组件构造函数里通过供应商令牌进行服务申请，比如： constructor(private logger: Logger) {} constructor声明 + @component + provide供应商数组 共同指示注入器要注入服务实例，以及怎么进行注入注意，我们在请求时是使用的供应商令牌来向注入器请求的，即上一节中的provide字段，而不管对应的实际供应商类或对象时哪个，注入器会自动根据令牌匹配一个服务实例来给组件使用，如果匹配不到，则创建一个实际上，在angular实现中，向注入器注册提供商时，会把这个提供商和一个DI令牌关联起来了，注入器自身会维护一个内部的令牌-提供商映射表，在请求依赖会从这个映射表查找提供商实例，而令牌就是这个表的键值，这就是为什么请求时使用的是令牌 （2）显式注入有两种显示注入方式，不过不提倡这么使用方式一：直接创建注入器 injector : any; constructor() { this.injector = ReflectiveInjector.resolveAndCreate([Logger, HeroService]); let logger = injector.get(Logger); } 方式二：直接使用注入器 heroService : any; constructor(private injector: Injector) {} ngOnInit() { this.heroService = this.injector.get(HeroService); } 4. 服务注入配置示意图服务注入的几个方面可以在下图得到体现 三. 多级注入系统点击这里查看原文，这里只是作一些总结 1) 嵌套式注入器Angular多级依赖注入系统支持与组件树并行的嵌套式注入器，应用程序中有一个与组件树平行的注入器树，我们可以在组件树中的任何级别上重新配置注入器每个组件实例都有自己的注入器，也许说不对，组件可以没有注入器，但这时候说的组件的注入器可能是一个组件树中更高级的祖先注入器的代理，可以理解为组件存了上级注入器的一个指针，,这只是提升效率的实现细节，只要想象成每个组件都有自己的注入器就可以了。 2) 注入冒泡angular自下而上冒泡的方式匹配使用的服务依赖，具体来讲，当一个组件请求一个服务时，Angular 先尝试用本组件自己的注入器来满足它，如果在该组件的注入器没有找到对应的提供商，它就把这个请求转给它父组件的注入器来处理；如果父组件注入器也无法满足这个申请，则继续往上传递，一直到找到了一个能处理此请求的注入器，或者超出了组件树中的祖先位置还未找到，抛出一个错误 3) 不同层级再次提供同一个服务在应用实现中，可以在注入器树中的多个层次上为指定的依赖令牌重新注册提供商，即同一个服务可以在多个层级上重新配置，多个子注入器都具有该服务的实例，根据注入的冒泡匹配原则，遇到的第一个提供商实例会胜出因此，注入器树中间层注入器上的提供商，可以拦截来自底层的对特定服务的请求，导致它可以“重新配置”和者说“遮蔽”高层的注入器带来的好处： 服务隔离,服务范围限制在组件内，别的组件不可访问 组件特殊的提供商,下级组件可重新定义与上级同名的服务，定义自己特殊的实现 多重编辑会话，每个组件实例拥有自己的服务实例，可以存放处理自己的数据 最后，一些好东西：1 . 在一个注入器的范围内，依赖都是单例的,比如在应用范围内的根注入器，各个依赖值都是单例的 2 . 注入器同时会实例化Component这样的组件,为什么不标记他们为@Injectable()呢？因为没有必要，因为组件已经有@Component装饰器， 而@Component/@Directive/@Pipe等装饰器都是 @Injectable的子类 3 . 可选依赖，使用@Optional()定义可选依赖，这样即使在注入器里没有这个服务，像这样： import { Optional } from &apos;@angular/core&apos;; constructor(@Optional() private logger: Logger) { if (this.logger) { this.logger.log(some_message); } } 这样的话在providers数组里可以不声明Logger，不会出错。不过使用的时候需要处理空值，因为当注入找不到这个服务时会返回一个null 4 . 非类依赖服务当注入对象是一个字符串，函数或者接口对象时，没有对应的合适令牌可供使用，可采用InjectionToken作为提供商令牌，像这样： //注入对像 export interface AppConfig { apiEndpoint: string; title: string; } export const HERO_DI_CONFIG: AppConfig = { apiEndpoint: &apos;api.heroes.com&apos;, title: &apos;Dependency Injection&apos; }; //令牌 import { InjectionToken } from &apos;@angular/core&apos;; export let APP_CONFIG = new InjectionToken&lt;AppConfig&gt;(&apos;app.config&apos;); //提供商 providers: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }] //使用@Inject装饰器帮忙注入使用 constructor(@Inject(APP_CONFIG) config: AppConfig) { this.title = config.title; }","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Angular-模块","date":"2017-07-15T08:39:05.000Z","path":"2017/07/15/angular-module/","text":"Angular采用模块的形式来组织应用，将相关业务功能或者有内部联系的部分进行内聚化设计，封装成单独的模块，而整个应该则由多个模块来构成 应用模块化模块化是一种设计模式，有着明显的优点: 打包特定领域/工作流的功能,隔离功能实现 方便组织应用，多个模块可独立开发 方便导入使用外部控件，很多Angular库和第三方库都是以模块形式提供，例如：FormsModule、HttpModule、RouterModule等 方便把服务加到应用程序中 模块化带来应用设计的简易化，应用组织就像搭积木一样方便，像这样： 模块的组成模块在angular里只是由@NgModule装饰器提供元数据的类，这个元数据对象指示如何编译和运行该模块，基本构成： @NgModule({ imports:[], //导入其它模块 declarations: [], // 声明组件指令管道 providers: [] //声明服务提供商 exports: [] //公开某些类 }) export class ContactModule { } (1) imports模块导入支持模块，会发生几件事：1 . 被导入模块公开的组件/指令/管道将和导入目标模块declarations合并，并供目标模块使用，但导入的成员优先级没目标模块的高2 . 被导入模块的providers会累加到导入目标模块的提供商，追加到@NgModule.providers中，并把它们注入到目标模块一级的注入器，比如导入到根模块，则注入到根注入器3 . 被导入的模块的路由和导入目标模块路由将合并 (2) declarations[]该数组声明本模块所拥有的组件，指令，管道等成员，数组里成员有以下特点： 数组里声明的成员默认都是私有的，除非放进exports公开他们 一个组件/指令/管道只能属于一个模块，不能同时把一个类声明在几个模块中 数组里的成员可以公开给其他模块直接导入使用 (3) providers[]模块是为模块中所有成员提供服务的最佳途径，在模块中声明服务提供商有几个特点： 模块内声明的服务商是模块级的，可供模块所有组件或其他成员使用 如果此模块被直接导入到根模块时，服务商注册到根注入器，整个应用都可使用 如果此模块被导入到延迟模块，则注入到模块子注入器，可供延迟模块内使用 延迟加载模块是限制服务商在模块内生效的唯一途径 (3) exports[]设置公开成员，至于在公开数组里声明的成员才能其他模块导入使用，可供导出的成员类型有如下几种： declarations数组中的成员 imports数组中的模块 不在imports数组中的其他模块(可不导入就直接导出) 模块成员导入后有两种使用方式：1 . 通过选择器直接在模板中使用，使用于组件/指令/管道2 . 通过路由导航来使用，适用于导入的组件，不过更好的设计是将路由移至被导入模块，导入后合并路由即可 如果是在本模块路由到导入模块的某个组件时，该组件不必公开，私有属性直接导入即可 模块树模块树是组成angular的基本树之一，体现了应用的基本结构,angular一般可通过直接导入和懒加载两种方式来将各个模块联系在一起，下图是一个基本模块树的关联结构： 应用模块的组建方式一个angular应用一般有四种类型的模块： 引导模块(AppModule)，一般指根模块，用于引导和组织整个应用 核心模块(CoreModule)，用于封装一次性的类，隐藏它们的实现细节，一般包含只在应用启动时使用到的组件类和全应用级服务提供商，根模块导入它来获取相关能力 共享模块(ShareModule)，用于封装公共组件、指令和管道，共享给那些需要它们的模块， 特性模块(FeatrueModule)，用于封装工作流和业务功能 下图是一个应用中模块的典型组建方式 最后，一些需要注意的细节：1 . 根模块和特性模块共享着相同的执行环境和同一个依赖注入器，在某个模块中定义的服务在所有其他模块中也都能用。特性模块通过自己提供的服务和对外公开的组件、指令、管道来与其它模块进行协同工作 2 . 在根注入器注册的提供商，每个服务均为单例，在全应用范围的组件都可使用，无论组件时主动导入还是惰性加载的 3 . 共享模块中不应出现providers服务商，否则如果一个惰性加载模块导入了此共享模块，就会相应生成一份服务的实例，这个在设计中时不被期望的 4 . 导入目标模块不会继承被导入模块中对组件、指令或管道的访问权，两个模块的imports数组是互不相干的，除非被导入模块将导入模块重新导出。所以，对公共模块的使用，并不是在根模块导入一次就可以了，而应该在每一个需要使用的模块中都需要导入 5 . 被导入模块的公开指令的优先级小于导入目标模块的指令，渲染时先执行导入的后执行本模块的，如果有同名指令存在，本模块的覆盖导入的；而如果在本模块的declarations如果有同名指令，后申明的覆盖先申明的 6 . 多次导入同一个指令是没问题的，Angular 会移除重复的类，只注册一次。但如果有两个不同的类，只是恰好有相同的名字，angular认为并没有重复，会同时保留这两个指令，只是在使用的时候两个指令都会先后调用到，优先级高的获最后结果 7 . 显式添加到AppModule中的那些提供商在优先级上要优于从其它模块中导入的提供商 8 . 立即模块加载是直接导入，在应用启动时加载它的路由和组件；懒加载模块是通过路由进行惰性加载，指的是用户第一次访问时异步获取加载文件，加载速度取决于浏览器一次加载文件的数量，比如：谷歌一般一次8个，所以要规划好懒加载模块的大小，以免加载时间过长 9 . 对于惰性加载模块，一般不要直接导入使用，因为一般这种模块都会有自己的路由配置，导入的同时也会导入它的路由，会对目标模块的路由导航造成影响，因为路由匹配是第一次匹配到即胜出的原则，如果惰性模块的路由和目标模块相似，会引起不必要的错误","tags":[{"name":"Augular","slug":"Augular","permalink":"http://blueskyawen.com/tags/Augular/"}]},{"title":"Hexo博客添加评论模块","date":"2017-06-10T16:43:11.000Z","path":"2017/06/11/hexo-add-pinglun/","text":"写好的东西总希望和人一起讨论分享，下面来给博客增加评论系统Yilia组图集成了多说，网易云跟帖，畅言，Disqus等众多评论系统，只需要简单的设置即可实现功能在这以网易云跟帖为例子说明 注册账号点击这里到网易云跟帖网站，按照流程注册账号，登录之后进入后台管理，填写站点信息，网址时你申请的域名获取代码到主题的/themes/yilia/layout/_partial/post/wangyiyun.ejs文件下，替换其内容 配置主题文件在/themes/yilia/_config.yml中找到评论配置,将wangyiyun改成true #评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus 不需要使用某项，直接设置值为false，或注释掉 #具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/ #1、多说 duoshuo: false #2、网易云跟帖 wangyiyun: true #3、畅言 changyan_appid: false changyan_conf: false #4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的 disqus: false 重新执行Hexo命令三件套，重新部署站点，查看效果","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blueskyawen.com/tags/hexo/"}]},{"title":"Hexo博客绑定个人域名","date":"2017-06-10T16:28:14.000Z","path":"2017/06/11/hexo-bind-domain/","text":"之前搭建完博客并且部署到github上以后，已经可以通过github.io地址来访问我的博客页面但这个地址这是仓库地址，缺乏个性，也为注册其他插件带来问题我在想，如果有自己的域名就好了，说干就干，由于已经在阿里云有了账号，下面以阿里云为例描述绑定域名的过程 1.购买域名进入阿里云官网，登录到域名购买页面输入个性的域名，查询注册情况，只要没被注册即可使用 2.身份认证注册完域名后，进入到自己的域名列表后需要进行个人信息填写和实名认证，这一步很重要，不然不能进行解析，一段时间后会被挂起状态，不能正常使用，所以还是认证的好，认证步骤有详细的提示，这里就不赘述了 3.域名解析进入到自己的域名列表，点击域名操作的解析，进入域名解析页面点击添加解析，填写配置： 类型–选择CNAME主机记录–@线路–默认记录值–填写博客仓库的名字：”your_github_name.github.io” 点击保存即可 4.仓库配置回到github仓库，在别根目录下增加名为CNAME的文件，内容为刚刚申请的域名为了防止以后部署提交会覆盖这个文件，可以在本地机子增加这个文件，然后PUSH到仓库里去 5.配置文件修改这个主要是要修改我们根目录的_config.yml，设置站点为/，否则如果存在子目录的话，部署后的主题会失效 # URL ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos; url: http://blueskyawen.com/ root: / 至此，域名更换和配置已经完全结束了，可以使用域名访问站点试试","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blueskyawen.com/tags/hexo/"}]},{"title":"Hexo主题配置","date":"2017-06-10T16:19:19.000Z","path":"2017/06/11/hexo-theme/","text":"之前搭建的博客有自己默认的主题，个人不喜欢，觉得略丑，体验也不好，于是懂了更换主题的念头。Hexo主题非常多，官网上主题库里有很多优秀的主题，大家可以根据自己的喜好来选择合适的主题由于Hexo是一款非常优秀的开源博客系统，所以github上也有大量的主题可供选择下面是github上star数量最多的前10个主题： iissnan/hexo-theme-next， 3510个star。litten/hexo-theme-yilia， 1703个star。TryGhost/Casper， 679个star。wuchong/jacman， 503个star。A-limon/pacman， 431个star。daleanthony/uno， 416个star。orderedlist/modernist， 367个star。AlxMedia/hueman， 336个star。kathyqian/crisp-ghost-theme， 303个star。xiangming/landscape-plus， 287个star。 我用的就是hexo-theme-yilia，感觉这个主题页面简单，正合心意1.clone主题代码在博客目录下执行命令clone主题代码： $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 完事在主题目录themes里增加yilia的主题代码 2.配置主题在博客根目录的_config.yml文件中，配置新主题 3.修改主题配置信息修改themes/yilia/_config.yml文件，修改的时候，每个冒号后面都需要留一个英文空格，不然报错，下面时我的配置文件，仅供参考 # Header menu: 主页: / 归档: /archives 随笔: /categories/随笔 相册: /photos # SubNav subnav: github: &quot;https://github.com/blueskyawen&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; qq: &quot;#&quot; #weixin: &quot;#&quot; #jianshu: &quot;#&quot; #mail: &quot;mailto:litten225@qq.com&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot; rss: /atom.xml # 是否需要修改 root 路径 # 如果您的网站存放在子目录中，例如 http://yoursite.com/blog， # 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 root: / # Content # 文章太长，截断按钮文字 excerpt_link: more # 文章卡片右下角常驻链接，不需要请设置为false show_all_link: &apos;展开全文&apos; # 数学公式 mathjax: false # 是否在新窗口打开链接 open_in_new: false fancybox: true top: true # 是否开启动画效果 animate: true # 打赏 # 请在需要打赏的文章的md文件头部，设置属性reward: true # 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏 reward_type: 2 # 打赏wording reward_wording: &apos;请随意打赏&apos; # 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg alipay: /images/IMG_zhifubao.jpg # 微信二维码图片地址 weixin: /images/IMG_weixin.jpg # Miscellaneous分析统计工具 baidu_analytics: &apos;&apos; #google_analytics: &apos;&apos; favicon: /images/favicon.jpg #你的头像url avatar: /images/touxiang.jpg #是否开启分享 share_jia: true share_addthis: false #评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus 不需要使用某项，直接设置值为false，或注释掉 #具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/ #1、多说 duoshuo: false #2、网易云跟帖 wangyiyun: true #3、畅言 changyan_appid: false changyan_conf: false #4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的 disqus: false # 样式定制 - 一般不需要修改，除非有很强的定制欲望… style: # 头像上面的背景颜色 header: &apos;#003f80&apos; # 右滑板块背景 slider: &apos;linear-gradient(200deg,#a0cfe4,#e8c37e)&apos; # slider的设置 slider: # 是否默认展开tags板块 showTags: false # 智能菜单 # 如不需要，将该对应项置为false # 比如 #smart_menu: # friends: false smart_menu: innerArchive: &apos;所有文章&apos; friends: &apos;链接&apos; aboutme: &apos;关于我&apos; friends: 天猫商城: https://www.tmall.com 阿里云: https://www.aliyun.com 携程: http://www.ctrip.com ZTE: http://www.zte.com.cn aboutme: 前端菜鸟&lt;br&gt;正在学习的路上前行&lt;br&gt;现就职于某通讯企业&lt;br&gt;长路漫漫，渐行渐远 4.查看主题效果仍然使用命令三件套来重新生成和部署站点，效果如下：","tags":[{"name":"hexo","slug":"hexo","permalink":"http://blueskyawen.com/tags/hexo/"}]},{"title":"hexo搭建个人博客","date":"2017-05-31T16:21:20.000Z","path":"2017/06/01/hexo-build-blok/","text":"一直想有一个自己的站点，用来写点东西，记录学习和生活偶然的机会，见识到了同事的博客，体验甚好，更加触动了自己搭建个人站点的想法从同事了解了下是用Hexo来搭建的，Hexo是一个超轻量级的博客系统，搭建起来很方便，我时自己百度各种资料，上官网学习，一步步搭建起来的，过程中也遇到各种问题，现总结一下，希望有所用。 一. 安装node.js和npm网上的安装指导教程很多，根据机器系统的不同有所不同，我的机子时ubuntu的，我是使用apt-get命令安装的 $ sudo apt-get install nodejs $ sudo apt-get install npm 看版本号有东西说明安装成功了 $ node -v v7.10.0 $ npm -v 4.2.0 推荐在线教程：菜鸟教程-Node.js 安装配置 二. 安装gitgit的安装方式也较多，可以百度搜一下，我是用apt-get安装的 $ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev $ apt-get install git-core $ git --version git version 2.9.3 推荐在线教程：菜鸟教程-Git 安装配置 三. 注册github点击上github官网，按照网站提示注册就可以了，注册成功后要去自己的邮箱验证接下来设置SSH-Key链接 ssh-keygen -t rsa -C &quot;email_name@163.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (/Users/root/.ssh/id_rsa): -&gt;按回车 Enter passphrase (empty for no passphrase): -&gt;输入密码 Enter same passphrase again: -&gt;再次输入密码 然后在个人账号的setting-&gt;SSH and GPG keys里点击Add SSH Key添加公开密钥即可，密钥为刚刚生成的id_rsa.pub文件里的内容，官网里也有添加SSH指导 四. 建立blog仓库官网有个给初学者提供的github的hello-world指导文档，可以先熟悉仓库的建设和分支管理创建博客仓库主要是创建和用户名对于的仓库，比如github用户名时blueskyawen,仓库名就叫blueskyawen.github.io创建github page进入刚刚创建的博客代理仓库，选择Settings进入设置页面，在GitHub Pages配置页面和主题,然后既可以通过地址:’your_name.github.io’来访问站点页面了 五. 安装配置Hexo这里时核心也是最重要的部分，有时间的人可以阅读hexo官网文档来学习全局安装hexo npm install hexo-cli -g 或 npm install -g hexo-cli 查看版本，有说明安装成功 hexo -v hexo-cli: 1.0.2 os: Linux 4.8.0-52-generic linux x64 http_parser: 2.7.0 node: 7.10.0 v8: 5.5.372.43 uv: 1.11.0 zlib: 1.2.11 ares: 1.10.1-DEV modules: 51 openssl: 1.0.2k icu: 58.2 unicode: 9.0 cldr: 30.0.3 tz: 2016j 初始化hexo hexo init blog cd blog npm install 启动服务，正常时这样的 hexo server INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器里输入以下地址访问页面：http://localhost:4000/ 部署到github先安装hexo-deployer npm install hexo-deployer-git --save 然后到博客根目录的_config.yml文件，找到deploy配置位置，填写上仓库地址，地址就是刚刚创建的那个github仓库的地址，可以从仓库首页面clone or download下拉框里直接拷贝然后出入下面的命令三件套，每一次修改都可以使用这三件套来部署 hexo clean hexo g hexo d 提示你输入github的用户名和密码，就OK了，然后你就可以使用your_githubName.github.io来访问自己的站点了，效果和本地跑的一样 六. Hexo常用命令下面时一Hexo常用的命令，平时可能会经常用到，也可以使用hexo -help自己查看各种命令的使用方法，括号内时简写 hexo clean -- 清理缓存文件 hexo generate(g) -- 生成静态文件 hexo server(s) -- 启动服务 hexo deploy(d) -- 部署站点 hexo d -g -- 生成加部署 hexo new &quot;Name&quot; -- 新建文章 hexo new draft &quot;Name&quot; -- 新建草稿文档 hexo --draft -- 显示草稿 hexo publish [layout] filename -- 发布草稿","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blueskyawen.com/tags/Hexo/"}]},{"title":"Markdown语法及编辑工具","date":"2017-05-29T09:19:02.000Z","path":"2017/05/29/markdown/","text":"花了好几天时间，终于把博客搭建好了。搭建博客是为了写点东西，记录下平时学习和生活的点滴，便于积累知识和查看。然而发现，记录文章是基于Markdown语法来书写的，所以在开始博客前先熟悉了下markdown语法，并对常用的一些语法作了下总结，基本可以满足平常的写作需求。 1. Markdown语法其实就是一种text to html的微语法，文本化的书写方式，最终还是由工具转化成html文档加以展示。 HTML兼容markdown语法对html标签是兼容的，在写作时可以随意使用html标签组织内容，但对于块级元素(比如:div)和行内元素标签(比如:span)和微语法的结合效果是不一样的:块级元素标签内markdown语法无效;而行内元素标签内markdown语法有效。 特殊字符的自动转化对于&amp; &lt; 这样的符号在html文档里有特殊意义的，但markdown会根据它们的使用场景进行自动转换，比如:当&lt;用于标签表示时工具不去理会，但是当只用于普通场景(3&lt;5)时会自动转化成对应的实体。 段落段落前后默认会有空行，如果需要在段落内换行，可敲2个空格加回车 标题markdown里有两种标题形式: 1). Setext # 标题1 ## 标题2 ### 标题3 #### 标题4 ##### 标题5 ###### 标题6 6级标题，#号越少，标题越高 2). atx 一级标题 ==== 二级标题 ---- 区块引用使用&gt;符号定义应用，可以多层嵌套 &gt; 外文引用 &gt; &gt; 外文引用 效果如下： 外文引用 外文引用 列表1). 无序列表:使用* + - 来构造无序列表 * 列表项目1 * 列表项目2 + 列表项目1 + 列表项目2 - 列表项目1 - 列表项目2 效果如下： 列表项目1 列表项目2 2). 有序列表:使用数字.来构造有序列表 1 列表项目1 2 列表项目2 效果如下： 列表项目1 列表项目2 注意：列表标记符号和项目内容之间须至少1个空格，最多3个空格 代码区块使用反引号`包围代码块，或者缩进4个空格来构造代码块，当代码块作为列表或引用的子元素时，可缩进到5个空格注意：代码块前后须加空行 分割线使用多个* - _ 来制造分隔线 *** --- ___ 效果如下：插入链接(1) 行内形式 [百度一下，你就知道](http://www.baidu.com &quot;baidu&quot;) 效果如下：百度一下，你就知道 (2) 参考形式 [百度一下，你就知道](1) [淘宝]() [1]: http://www.baidu.com &quot;baidu&quot; [淘宝]: http://www.taobao.com &quot;taobao&quot; 效果如下：百度一下，你就知道淘宝 注意：参考形式的url定义处和使用处须有空行，一般放在段落后面或文章最尾部 插入图像与链接类似，也分行内形式和参考形式 ![text](url &quot;title&quot;) ![text][id] [id]: url &quot;title&quot; 效果如下: 字体单个*斜体，俩个粗体 *斜体* **粗体** ***斜体+粗体*** 效果如下：斜体粗体斜体+粗体 表格| Left-Aligned | Center Aligned | Right Aligned | | :------------ |:---------------:| -----:| | col 3 is | some wordy text | $1600 | | col 2 is | centered | $12 | 效果如下： Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 其中，:—左对齐，:—:中间对齐，—:左对齐， 2. Markdown工具有许多的markdown语法转换工具，提供便捷书写和实时预览的功能，帮助方便的编辑文档，个人推荐以下，可在线编辑: Markdown plus: Markdown编辑器，可以支持添加任务列表、emoji、流程图等 作业部落: 在线 Markdown 编辑器推出桌面版客户端啦，全平台支援。 参考： Markdown 语法说明(简体中文版)-http://www.appinn.com/markdown/","tags":[{"name":"写作","slug":"写作","permalink":"http://blueskyawen.com/tags/写作/"}]}]
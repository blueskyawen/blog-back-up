---
title: Angular-模块
date: 2017-07-15 16:39:05
tags: Augular
categories: 前端
comments: true
---

Angular采用模块的形式来组织应用，将相关业务功能或者有内部联系的部分进行内聚化设计，封装成单独的模块，而整个应该则由多个模块来构成

## 应用模块化
模块化是一种设计模式，有着明显的优点:
<!--more-->
- 打包特定领域/工作流的功能,隔离功能实现
- 方便组织应用，多个模块可独立开发
- 方便导入使用外部控件，很多Angular库和第三方库都是以模块形式提供，例如：FormsModule、HttpModule、RouterModule等
- 方便把服务加到应用程序中

模块化带来应用设计的简易化，应用组织就像搭积木一样方便，像这样：
![app-module-jimu](/images/app-module-jimu.jpg)

## 模块的组成
模块在angular里只是由@NgModule装饰器提供元数据的类，这个元数据对象指示如何编译和运行该模块，基本构成：

    @NgModule({
        imports:[], //导入其它模块
        declarations: [], // 声明组件指令管道
        providers: []  //声明服务提供商
        exports: []  //公开某些类
    })
    export class ContactModule { }


#### (1) imports模块
导入支持模块，会发生几件事：
1 . 被导入模块公开的组件/指令/管道将和导入目标模块declarations合并，并供目标模块使用，但导入的成员优先级没目标模块的高
2 . 被导入模块的providers会累加到导入目标模块的提供商，追加到@NgModule.providers中，并把它们注入到目标模块一级的注入器，比如导入到根模块，则注入到根注入器
3 . 被导入的模块的路由和导入目标模块路由将合并


#### (2) declarations[]
该数组声明本模块所拥有的组件，指令，管道等成员，数组里成员有以下特点：
+  数组里声明的成员默认都是私有的，除非放进exports公开他们
+  一个组件/指令/管道只能属于一个模块，不能同时把一个类声明在几个模块中
+  数组里的成员可以公开给其他模块直接导入使用


#### (3) providers[]
模块是为模块中所有成员提供服务的最佳途径，在模块中声明服务提供商有几个特点：
* 模块内声明的服务商是模块级的，可供模块所有组件或其他成员使用
* 如果此模块被直接导入到根模块时，服务商注册到根注入器，整个应用都可使用
* 如果此模块被导入到延迟模块，则注入到模块子注入器，可供延迟模块内使用
* 延迟加载模块是限制服务商在模块内生效的唯一途径


#### (3) exports[]
设置公开成员，至于在公开数组里声明的成员才能其他模块导入使用，可供导出的成员类型有如下几种：
- declarations数组中的成员
- imports数组中的模块
- 不在imports数组中的其他模块(可不导入就直接导出)

模块成员导入后有两种使用方式：
1 . 通过选择器直接在模板中使用，使用于组件/指令/管道
2 . 通过路由导航来使用，适用于导入的组件，不过更好的设计是将路由移至被导入模块，导入后合并路由即可
> 如果是在本模块路由到导入模块的某个组件时，该组件不必公开，私有属性直接导入即可

## 模块树
模块树是组成angular的基本树之一，体现了应用的基本结构,angular一般可通过直接导入和懒加载两种方式来将各个模块联系在一起，下图是一个基本模块树的关联结构：
![angular-module-tree](/images/module-tree.jpg)


## 应用模块的组建方式
一个angular应用一般有四种类型的模块：
- 引导模块(AppModule)，一般指根模块，用于引导和组织整个应用
- 核心模块(CoreModule)，用于封装一次性的类，隐藏它们的实现细节，一般包含只在应用启动时使用到的组件类和全应用级服务提供商，根模块导入它来获取相关能力
- 共享模块(ShareModule)，用于封装公共组件、指令和管道，共享给那些需要它们的模块，
- 特性模块(FeatrueModule)，用于封装工作流和业务功能

下图是一个应用中模块的典型组建方式
![app-module-construct](/images/app-construct.jpg)


#### 最后，一些需要注意的细节：

1 . 根模块和特性模块共享着相同的执行环境和同一个依赖注入器，在某个模块中定义的服务在所有其他模块中也都能用。特性模块通过自己提供的服务和对外公开的组件、指令、管道来与其它模块进行协同工作

2 . 在根注入器注册的提供商，每个服务均为单例，在全应用范围的组件都可使用，无论组件时主动导入还是惰性加载的

3 . 共享模块中不应出现providers服务商，否则如果一个惰性加载模块导入了此共享模块，就会相应生成一份服务的实例，这个在设计中时不被期望的

4 . 导入目标模块不会继承被导入模块中对组件、指令或管道的访问权，两个模块的imports数组是互不相干的，除非被导入模块将导入模块重新导出。所以，对公共模块的使用，并不是在根模块导入一次就可以了，而应该在每一个需要使用的模块中都需要导入

5 . 被导入模块的公开指令的优先级小于导入目标模块的指令，渲染时先执行导入的后执行本模块的，如果有同名指令存在，本模块的覆盖导入的；而如果在本模块的declarations如果有同名指令，后申明的覆盖先申明的

6 . 多次导入同一个指令是没问题的，Angular 会移除重复的类，只注册一次。但如果有两个不同的类，只是恰好有相同的名字，angular认为并没有重复，会同时保留这两个指令，只是在使用的时候两个指令都会先后调用到，优先级高的获最后结果

7 . 显式添加到AppModule中的那些提供商在优先级上要优于从其它模块中导入的提供商

8 . 立即模块加载是直接导入，在应用启动时加载它的路由和组件；懒加载模块是通过路由进行惰性加载，指的是用户第一次访问时异步获取加载文件，加载速度取决于浏览器一次加载文件的数量，比如：谷歌一般一次8个，所以要规划好懒加载模块的大小，以免加载时间过长

9 . 对于惰性加载模块，一般不要直接导入使用，因为一般这种模块都会有自己的路由配置，导入的同时也会导入它的路由，会对目标模块的路由导航造成影响，因为路由匹配是第一次匹配到即胜出的原则，如果惰性模块的路由和目标模块相似，会引起不必要的错误